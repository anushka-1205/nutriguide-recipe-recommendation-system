# -*- coding: utf-8 -*-
"""Final_AI_Project.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1BG8ZYD-foPJX3EBbxBsYFccaZZQB1m_i

## **NutriGuide: Recipe Recommendation System**
###### An AI project that provides Indian recipe suggestions based on ingredients, calorie limit, and an optional diet type!
"""

import numpy as np
import pandas as pd

import os
for dirname, _, filenames in os.walk('/content'):
    for filename in filenames:
        print(os.path.join(dirname, filename))

df = pd.read_csv('/content/IndianFoodDatasetCSV2.csv')

df.dropna(subset=['TranslatedIngredients', 'EstimatedCalories'], inplace=True)

df.head()

df.info()

df.isnull().sum()

df['Cuisine'].unique()

df['Diet'].unique()

df['Course'].unique()

pd.set_option('display.max_colwidth', None)
df['TranslatedIngredients']

import re
non_english_pattern = re.compile(r'[^\x00-\x7F]+')
mask = df['TranslatedIngredients'].str.contains(non_english_pattern, na=False)
df_english = df[~mask].reset_index(drop=True)

df_english['TranslatedIngredients'].head()

import spacy

work = spacy.load("en_core_web_sm")

def extract_ingredients(text):
    if pd.isnull(text):
        return ""
    doc = work(text)
    ingredients = [token.text for token in doc if token.pos_ in ['NOUN', 'PROPN'] or token.dep_ == 'compound']
    return ', '.join(ingredients)

df_english.loc[:, 'ExtractedIngredients'] = df_english['TranslatedIngredients'].apply(extract_ingredients)

df_english['ExtractedIngredients'].head()

def clean_ingredients(text):
    text = re.sub(r'\d+', '', text)
    text = re.sub(r'[()\[\]/]', '', text)
    return text

df_english.loc[:, 'ExtractedIngredients'] = df_english['ExtractedIngredients'].apply(clean_ingredients)

df_english.info()

df_english['TranslatedIngredients']

df_english['ExtractedIngredients'].head()

import nltk
nltk.download('punkt')
nltk.download('stopwords')

from nltk.corpus import stopwords

stop_words = set(stopwords.words('english'))

# stop_words = {'a', 'about', 'above', 'after', 'again', 'against', 'ain', 'all', 'am', 'an', 'and', 'any', 'are', 'aren', "aren't", 'as', 'at', 'be', 'because', 'been', 'before', 'being', 'below', 'between', 'both', 'but', 'by', 'can', 'couldn', "couldn't", 'd', 'did', 'didn', "didn't", 'do', 'does', 'doesn', "doesn't", 'doing', 'don', "don't", 'down', 'during', 'each', 'few', 'for', 'from', 'further', 'had', 'hadn', "hadn't", 'has', 'hasn', "hasn't", 'have', 'haven', "haven't", 'having', 'he', "he'd", "he'll", "he's", 'her', 'here', 'hers', 'herself', 'him', 'himself', 'his', 'how', 'i', "i'd", "i'll", "i'm", "i've", 'if', 'in', 'into', 'is', 'isn', "isn't", 'it', "it'd", "it'll", "it's", 'its', 'itself', 'just', 'll', 'm', 'ma', 'me', 'mightn', "mightn't", 'more', 'most', 'mustn', "mustn't", 'my', 'myself', 'needn', "needn't", 'no', 'nor', 'not', 'now', 'o', 'of', 'off', 'on', 'once', 'only', 'or', 'other', 'our', 'ours', 'ourselves', 'out', 'over', 'own', 're', 's', 'same', 'shan', "shan't", 'she', "she'd", "she'll", "she's", 'should', "should've", 'shouldn', "shouldn't", 'so', 'some', 'such', 't', 'than', 'that', "that'll", 'the', 'their', 'theirs', 'them', 'themselves', 'then', 'there', 'these', 'they', "they'd", "they'll", "they're", "they've", 'this', 'those', 'through', 'to', 'too', 'under', 'until', 'up', 've', 'very', 'was', 'wasn', "wasn't", 'we', "we'd", "we'll", "we're", "we've", 'were', 'weren', "weren't", 'what', 'when', 'where', 'which', 'while', 'who', 'whom', 'why', 'will', 'with', 'won', "won't", 'wouldn', "wouldn't", 'y', 'you', "you'd", "you'll", "you're", "you've", 'your', 'yours', 'yourself', 'yourselves'}

def preprocess_text(text):
    text = text.lower()
    text = ''.join([char for char in text if char not in string.punctuation])
    tokens = text.split()
    tokens = [word for word in tokens if word not in stop_words]
    return ' '.join(tokens)

import string
df_english.loc[:, 'CleanedIngredients'] = df_english['ExtractedIngredients'].apply(preprocess_text)

df_english = df_english[df_english['CleanedIngredients'].str.strip() != ''].copy()

df_english.info()

from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity

tfidf_vectorizer = TfidfVectorizer()
tfidf_matrix = tfidf_vectorizer.fit_transform(df_english['CleanedIngredients'])

def calculate_similarity(user_ingredients, calories):
    user_ingredients_text = preprocess_text(', '.join(user_ingredients))
    user_tfidf = tfidf_vectorizer.transform([user_ingredients_text])
    cosine_similarities = cosine_similarity(user_tfidf, tfidf_matrix)[0]
    calories_similarity = 1 - abs(df_english['EstimatedCalories'] - calories) / df_english['EstimatedCalories'].max()
    combined_similarity = (cosine_similarities * 0.8) + (calories_similarity * 0.2)
    return combined_similarity

def recommend_recipes(user_ingredients, diet='', calories=150, top_n=5):
    combined_similarity = calculate_similarity(user_ingredients, calories)
    sorted_indices = combined_similarity.argsort()[::-1]

    if diet:
        filtered_indices = [idx for idx in sorted_indices if df_english.loc[idx, 'Diet'].strip().lower() == diet.lower()]
        top_recommendations = df_english.loc[filtered_indices[:top_n], ['TranslatedRecipeName','TranslatedInstructions', 'Diet', 'EstimatedCalories']].copy()
    else:
        top_recommendations = df_english.iloc[sorted_indices[:top_n], df_english.columns.get_indexer(['TranslatedRecipeName','TranslatedInstructions', 'Diet', 'EstimatedCalories'])].copy()

    return top_recommendations

user_ingredients = ["tomato","pepper","onion"]
diet = "Vegan"
recommendations = recommend_recipes(user_ingredients, diet, 250, 15)

# for index in recommendations.index:
#     recipe_info = df_english.loc[index]
#     print("Recipe Information for Index", index)
#     print(recipe_info)
#     print("---------------------------------------------------------------------------------------------")





from IPython.display import HTML

html_table = "<table><tr><th>Srno</th><th>Name</th><th>Diet</th><th>Recipe</th><th>Estimated Calories</th></tr>"

for index in recommendations.index:
    recipe_info = df_english.loc[index]
    html_table += f"<tr><td>{recipe_info.get('Srno', '')}</td><td>{recipe_info.get('TranslatedRecipeName', '')}</td><td>{recipe_info.get('Diet', '')}</td><td>{recipe_info.get('TranslatedInstructions', '')}</td><td>{recipe_info.get('EstimatedCalories', '')}</td></tr>"

html_table += "</table>"

HTML(html_table)

"""#### RUN GRADIO WITH CAUTION! Ensure to demo.close() after use and delete runtime as well."""

# RUN GRADIO WITH CAUTION! Ensure to demo.close() after use and delete runtime as well.

# !pip install gradio --quiet --upgrade

# import gradio as gr
# import pandas as pd

# from gradio.themes.base import Base

# blue_theme = Base(
#     primary_hue="blue",
#     secondary_hue="blue"
# )

# diet_options = [
#     '', 'Diabetic Friendly', 'Vegetarian', 'High Protein Vegetarian',
#     'Non Vegeterian', 'High Protein Non Vegetarian', 'Eggetarian',
#     'Vegan', 'No Onion No Garlic (Sattvic)', 'Gluten Free', 'Sugar Free Diet'
# ]

# def get_recipes(ingredients, calories, diet, top_n):
#     ingredients_list = [i.strip() for i in ingredients.split(",") if i.strip()]
#     try:
#         df = recommend_recipes(ingredients_list, diet=diet, calories=calories, top_n=top_n)

#         if df.empty:
#             return "‚ö†Ô∏è No recipes found matching the criteria."

#         column_rename_map = {
#             'TranslatedRecipeName': 'Name',
#             'TranslatedInstructions': 'Recipe',
#             'EstimatedCalories': 'Estimated Calories',
#             'Diet': 'Diet'
#         }

#         df = df.rename(columns=column_rename_map)
#         df = df.reset_index(drop=True)

#         output_str = ""
#         for i, row in df.iterrows():
#             output_str += f"### üçΩÔ∏è NutriGuide: Recipe #{i+1}\n\n"
#             output_str += f"**Recipe Name**: {row.get('Name', 'N/A')}\n\n"
#             output_str += f"**Recipe**: {row.get('Recipe', 'N/A')}\n\n"
#             output_str += f"**Diet**: {row.get('Diet', 'N/A')}\n\n"
#             output_str += f"**Estimated Calories**: {row.get('Estimated Calories', 'N/A')}\n\n"
#             output_str += "---\n"

#         return output_str

#     except Exception as e:
#         return f"‚ùå Error: {e}"

# with gr.Blocks(theme=blue_theme) as demo:
#   gr.HTML("""
#            <style>
#                .blue-button {
#                    background-color: #3B82F6 !important;
#                    color: white !important;
#                    border: none;
#                    padding: 12px 24px;
#                    font-size: 16px;
#                    border-radius: 6px;
#                    cursor: pointer;
#                }
#                .blue-button:hover {
#                    background-color: #2563EB !important;
#                }
#            </style>
#      """)

#   gr.HTML("<h1 style='text-align:center; margin-bottom: 0;'>üçΩÔ∏è NutriGuide: Recipe Recommendation System üçΩÔ∏è</h1>")
#   gr.HTML("<p style='text-align:center; margin-top: 0; margin-bottom: 40px;'>Provide ingredients, calorie limit, and an optional diet type to get Indian recipe suggestions.</p>")

#   with gr.Row():
#       ingredients = gr.Textbox(label="Enter ingredients (comma-separated)", placeholder="e.g., tomato, onion, garlic")
#   with gr.Row():
#       calories = gr.Number(label="Average Calories", value=250)
#       diet = gr.Dropdown(label="Select Diet (optional)", choices=diet_options)
#       top_n = gr.Slider(label="Number of Recipes to Recommend", minimum=1, maximum=20, value=5, step=1)
#   output = gr.Markdown(label="Recommended Recipes")
#   submit = gr.Button("Get Recommendations", elem_classes=["blue-button"])
#   submit.click(fn=get_recipes, inputs=[ingredients, calories, diet, top_n], outputs=output)

# demo.launch(auth=("admin", "passwordforcollege9876"))

# demo.close()